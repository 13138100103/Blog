# Host: 47.102.140.226  (Version 5.5.57-log)
# Date: 2019-06-17 19:33:50
# Generator: MySQL-Front 6.1  (Build 1.26)


#
# Structure for table "article"
#

CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_user_id` int(11) unsigned DEFAULT NULL,
  `article_title` varchar(255) DEFAULT NULL,
  `article_content` mediumtext,
  `article_view_count` int(11) DEFAULT '0',
  `article_comment_count` int(11) DEFAULT '0',
  `article_create_time` datetime DEFAULT NULL,
  `article_update_time` datetime DEFAULT NULL,
  `article_summary` text,
  `article_category` varchar(255) DEFAULT NULL,
  `article_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

#
# Data for table "article"
#

INSERT INTO `article` VALUES (1,1,'[转载]IDEA快捷键大全','<div>\n                                <div>\n                                <p></p><blockquote>1. IDEA内存优化(秒开的快感!!)</blockquote><br>\\IntelliJ IDEA8\\bin\\idea.exe.vmoptions&nbsp;&nbsp;<br><br>-----------------------------------------&nbsp;&nbsp;<br><p></p><pre><code>-Xms2048m     <br>-Xmx2048m  <br>-XX:MaxPermSize=512m  <br>-ea  <br>-server  <br>-Dsun.awt.keepWorkingSetOnMinimize=true</code></pre><p>------------------------------------------------<br><br>&nbsp;<br><br></p><blockquote>实用快捷键:</blockquote><br>Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/*...*/ ）<br>Ctrl+D 复制行<br>Ctrl+X 删除行<br>快速修复 alt+enter(modify/cast)<br>代码提示 alt+/<br>ctr+G 定位某一行<br>Shift+F6 重构-重命名&nbsp;IDEA 批量修改变量名 点击变量名后按shift+F6<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br><br>代码处F2 快速定位编译出错位置<br><br>Ctrl+E 最近打开的文件<br>Ctrl+J 自动代码<br><br>Ctrl+ home/end 抵达文件头部,底部<br><br>组织导入 ctr+alt+O<br>格式化代码 ctr+alt+L<br>大小写转化 ctr+shift+U<br><br>--------------------------<br><blockquote>IntelliJ Idea 常用快捷键列表</blockquote><br>Alt+回车导入包,自动修正<br>Ctrl+N&nbsp;&nbsp; 查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L&nbsp; 格式化代码<br><br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等)<br>Ctrl+E或者Alt+Shift+C&nbsp; 最近更改的代码<br>Ctrl+R 替换文本<br><br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格代码提示<br><br>Ctrl+Alt+Space 类名或接口名提示<br><br>Ctrl+P 方法参数提示<br><br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br><br>Alt+Shift+C 对比最近修改的代码<br><br>&nbsp;<br><br>Shift+F6&nbsp; 重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+/ 或&nbsp;Ctrl+Shift+/&nbsp; 注释（// 或者/*...*/&nbsp;）<br>Ctrl+J&nbsp; 自动代码<br>Ctrl+E 最近打开的文件<br><br>Ctrl+H 显示类结构图<br><br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br><br>Ctrl+Alt+left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br><br>Alt+ Up/Down 在方法间快速移动定位<br><br>Ctrl+Shift+Up/Down代码向上/下移动。<br><br>F2 或Shift+F2 高亮错误或警告快速定位<br><br>代码标签输入完成后，按Tab，生成代码。<br><br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br><br>Ctrl+W 选中代码，连续按会有其他效果<br><br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br><br>Ctrl+Up/Down&nbsp;光标跳转到第一行或最后一行下<br><br>Ctrl+B&nbsp;快速打开光标处的类或方法&nbsp;<br><br>Ctrl+O 查看该类可以重写哪些方法<br><br>------------------------------------------------------------------------------------------------------------<p></p><p><br></p><blockquote>2. 查询快捷键</blockquote><br>CTRL+N&nbsp;&nbsp;查找类&nbsp;<br>CTRL+SHIFT+N&nbsp; 查找文件&nbsp;<br>CTRL+SHIFT+ALT+N 查找类中的方法或变量&nbsp;<br>CIRL+B&nbsp;&nbsp; 找变量的来源&nbsp;<br>CTRL+ALT+B&nbsp; 找所有的子类&nbsp;<br>CTRL+SHIFT+B&nbsp; 找变量的类&nbsp;<br>CTRL+G&nbsp;&nbsp; 定位行&nbsp;<br>CTRL+F&nbsp;&nbsp; 在当前窗口查找文本&nbsp;<br>CTRL+SHIFT+F&nbsp; 在指定窗口查找文本&nbsp;<br>CTRL+R&nbsp;&nbsp; 在当前窗口替换文本&nbsp;<br>CTRL+SHIFT+R&nbsp; 在指定窗口替换文本&nbsp;<br>ALT+SHIFT+C&nbsp; 查找修改的文件&nbsp;<br>CTRL+E&nbsp;&nbsp; 最近打开的文件&nbsp;<br>F3&nbsp;&nbsp; 向下查找关键字出现位置&nbsp;<br>SHIFT+F3&nbsp; 向上一个关键字出现位置&nbsp;<br>F4&nbsp;&nbsp; 查找变量来源&nbsp;<br>CTRL+ALT+F7&nbsp; 选中的字符查找工程出现的地方&nbsp;<br>CTRL+SHIFT+O&nbsp; 弹出显示查找内容<br><br><blockquote>3. 自动代码</blockquote><br>ALT+回车&nbsp; 导入包,自动修正&nbsp;<br>CTRL+ALT+L&nbsp; 格式化代码&nbsp;<br>CTRL+ALT+I&nbsp; 自动缩进&nbsp;<br>CTRL+ALT+O&nbsp; 优化导入的类和包&nbsp;<br>ALT+INSERT&nbsp; 生成代码(如GET,SET方法,构造函数等)&nbsp;<br>CTRL+E 最近更改的代码&nbsp;<br>CTRL+SHIFT+SPACE 自动补全代码&nbsp;<br>CTRL+空格&nbsp; 代码提示&nbsp;<br>CTRL+ALT+SPACE&nbsp; 类名或接口名提示&nbsp;<br>CTRL+P&nbsp;&nbsp; 方法参数提示&nbsp;<br>CTRL+J&nbsp;&nbsp; 自动代码&nbsp;<br>CTRL+ALT+T&nbsp; 把选中的代码放在 TRY{} IF{} ELSE{}里<br><br>CTRL+ALT+M&nbsp; 抽取方法<br><br><blockquote>4. 复制快捷方式</blockquote><br>CTRL+D&nbsp;&nbsp;复制行&nbsp;<br>CTRL+X&nbsp;&nbsp; 剪切,删除行&nbsp;&nbsp;<br><br><blockquote>5. 其他快捷方式</blockquote><br>CIRL+U&nbsp;&nbsp;大小写切换&nbsp;<br>CTRL+Z&nbsp;&nbsp; 倒退&nbsp;<br>CTRL+SHIFT+Z&nbsp; 向前&nbsp;<br>CTRL+ALT+F12&nbsp; 资源管理器打开文件夹&nbsp;<br>ALT+F1&nbsp;&nbsp; 查找文件所在目录位置&nbsp;<br>SHIFT+ALT+INSERT 竖编辑模式&nbsp;<br>CTRL+/&nbsp;&nbsp; 注释//&nbsp;&nbsp;&nbsp;<br>CTRL+SHIFT+/&nbsp; 注释/*...*/&nbsp;<br>CTRL+W&nbsp;&nbsp; 选中代码，连续按会有其他效果&nbsp;<br>CTRL+B&nbsp;&nbsp; 快速打开光标处的类或方法&nbsp;<br>ALT+ ←/→&nbsp;切换代码视图&nbsp;<br>CTRL+ALT ←/→&nbsp;返回上次编辑的位置&nbsp;<br>ALT+ ↑/↓&nbsp;在方法间快速移动定位&nbsp;<br>SHIFT+F6&nbsp; 重构-重命名&nbsp;<br>CTRL+H&nbsp;&nbsp; 显示类结构图&nbsp;<br>CTRL+Q&nbsp;&nbsp; 显示注释文档&nbsp;<br>ALT+1&nbsp;&nbsp; 快速打开或隐藏工程面板&nbsp;<br>CTRL+SHIFT+UP/DOWN 代码向上/下移动。&nbsp;<br>CTRL+UP/DOWN&nbsp; 光标跳转到第一行或最后一行下&nbsp;<br>ESC&nbsp;&nbsp; 光标返回编辑框&nbsp;<br>SHIFT+ESC&nbsp; 光标返回编辑框,关闭无用的窗口&nbsp;<br>F1&nbsp;&nbsp; 帮助千万别按,很卡!&nbsp;<br>书签帮助L(操作非数字键盘的数字!!!!!!!)<br><br>Ctrl +Shift+1-9&nbsp;书签定位行为1-9 或者字母,<br><br>Ctrl + 1-9 自动跳转到锁定位的书签位置<br><br>Ctrl+ F9 重新编译, 删除缓存.实时更新<br><br>Ctrl+Shift+U 大小写切换<br><p></p>\n                                </div><p><br></p>\n                                </div><p><br></p>',95,0,'2019-05-29 14:36:33',NULL,'','JAVA后端',1),(2,1,'SpringMVC的上传与下载','<div>\n                                <div>\n                                <p>先记着</p></div>\n                                </div><p><br></p>',10,0,'2019-06-02 10:25:59',NULL,'','JAVA后端',1),(3,1,'JAVA集合详解','<div>\n                                <div>\n                                <h1>一、集合大纲</h1>\n                                </div><p><br></p><blockquote><h3>1.集合和数组的区别：</h3></blockquote>\n                                </div><p><img src=\"/Blog/upload/397bae89-29f0-4960-bea7-8eca0e276283.png\" style=\"max-width: 100%;\"></p><p><br></p><blockquote><h3>&nbsp; 2.Collection集合的方法：</h3></blockquote><p><img src=\"/Blog/upload/d3e23b02-567b-4595-9072-f795a6bdd434.png\" style=\"max-width:100%;\"><br></p><p><br></p><blockquote><h4 id=\"3常用集合的分类\">3.常用集合的分类：</h4></blockquote><p><h3>Collection 接口的接口 对象的集合（单列集合）<br><h3>├——-List 接口：元素按进入先后有序保存，可重复<br><h3>│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-└ Vector 接口实现类 数组， 同步， 线程安全<br>│ ———————-└ Stack 是Vector类的实现类<br>└——-Set 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-└HashSet 使用hash表（数组）存储元素<br>│————————└ LinkedHashSet 链表维护元素的插入次序<br>└ —————-TreeSet 底层实现为二叉树，元素排好序<br>Map 接口 键值对的集合 （双列集合）<br>├———Hashtable 接口实现类， 同步， 线程安全<br>├———HashMap 接口实现类 ，没有同步， 线程不安全-<br>│—————–├ LinkedHashMap 双向链表和哈希表实现<br>│—————–└ WeakHashMap<br>├ ——–TreeMap 红黑树对所有的key进行排序<br>└———IdentifyHashMap</h3></h3></h3><div><br></div></p><h1>二、List和Set集合详解：</h1><p><br></p><blockquote><h3>1.list和set的区别：</h3></blockquote><div></div><p><img src=\"/Blog/upload/4f03d772-c9f5-4a68-ae05-c1653ebfac8b.png\" style=\"max-width:100%;\"></p><p><br></p><blockquote><h3>2.List：</h3></blockquote><p><h3>（1）ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素<br>（2）LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素<br>（3）Vector:底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素 </h3><div><img src=\"/Blog/upload/549aef7d-c0a6-485b-95a1-cc7a06717237.png\" style=\"max-width:100%;\"><br></div><div><br></div><div><br></div></p><blockquote><h3>3.Set：</h3></blockquote><div><p></p><h3><h5><p>(1)HashSet底层数据结构采用哈希表实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。</p><p><br>具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。</p><p><br>Set的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。<br>Object类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。</p><p><br>Hash算法是一种散列算法。<br>Set hs=new HashSet();<br>hs.add(o);<br>|<br>o.hashCode();<br>|<br>o%当前总容量 (0–15)<br>|<br>| 不发生冲突<br>是否发生冲突—————–直接存放<br>|<br>| 发生冲突<br>| 假（不相等）<br>o1.equals(o2)——————-找一个空位添加<br>|<br>| 是（相等）<br>不添加</p><p><br>覆盖hashCode()方法的原则：<br>1、一定要让那些我们认为相同的对象返回相同的hashCode值<br>2、尽量让那些我们认为不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。<br>3、尽量的让hashCode值散列开（两值用异或运算可使结果的范围更广）</p><p><br>HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，我们应该为保存到HashSet中的对象覆盖hashCode()和equals()，因为再将对象加入到HashSet中时，会首先调用hashCode方法计算出对象的hash值，接着根据此hash值调用HashMap中的hash方法，得到的值&amp; (length-1)得到该对象在hashMap的transient Entry[] table中的保存位置的索引，接着找到数组中该索引位置保存的对象，并调用equals方法比较这两个对象是否相等，如果相等则不添加，注意：所以要存入HashSet的集合对象中的自定义类必须覆盖hashCode(),equals()两个方法，才能保证集合中元素不重复。在覆盖equals()和hashCode()方法时， 要使相同对象的hashCode()方法返回相同值，覆盖equals()方法再判断其内容。为了保证效率，所以在覆盖hashCode()方法时， 也要尽量使不同对象尽量返回不同的Hash码值。<br>如果数组中的元素和要加入的对象的hashCode()返回了相同的Hash值（相同对象）,才会用equals()方法来判断两个对象的内容是否相同。</p><p><br>(2)LinkedHashSet底层数据结构采用链表和哈希表共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。线程不安全，效率高。</p><p><br>(3)TreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；</p><p><br>（4）小结：Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只 是行为不同</p><p><br>4.List和Set总结：</p><p>（1）List,Set都是继承自Collection接口，Map则不是&nbsp;</p><p><br>（2）List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）&nbsp;</p><p><br>（3）Set和List对比：&nbsp;<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p><p><br>（4）ArrayList与LinkedList的区别和适用场景&nbsp;<br><span style=\"font-weight: bold;\">Arraylist：<br></span>优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br>缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p><p><br><span style=\"font-weight: bold;\">LinkedList：<br></span>优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景<br>缺点：因为LinkedList要移动指针,所以查询操作性能比较低。<br>适用场景分析：<br>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。<br>ArrayList与Vector的区别和适用场景<br>ArrayList有三个构造方法：<br><code>public ArrayList(int initialCapacity)//构造一个具有指定初始容量的空列表。    <br></code><code>public ArrayList()      //默认构造一个初始容量为10的空列表。    <br></code><code>public ArrayList(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 的元素的列表<br></code>Vector有四个构造方法：&nbsp;&nbsp;<br><code>public Vector()//使用指定的初始容量和等于0的容量增量构造一个空向量。    <br></code><code>public Vector(int initialCapacity)//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。    <br></code><code>public Vector(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 中的元素的向量    <br></code><code>public Vector(int initialCapacity,int capacityIncrement)//使用指定的初始容量和容量增量构造一个空的向量<br></code><br></p><p>ArrayList和Vector都是用数组实现的，主要有这么三个区别：</p><p><br>（1）Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>（2）两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>（3）Vector可以设置增长因子，而ArrayList不可以。<br>（4）Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p><p><br><strong style=\"font-size: 16.38px;\">适用场景分析</strong><span style=\"font-size: 16.38px;\">:</span></p><p><span style=\"font-size: 16.38px;\">HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</span><span style=\"font-size: 16.38px;\">&nbsp;<br></span>（5）何时使用：&nbsp;&nbsp;&nbsp;</p><div><p><img src=\"/Blog/upload/988f853b-164e-4b86-9d0c-877ca954cbad.png\" style=\"max-width:100%;\"><br></p><h2><br>三、Map详解：</h2></div><div><p><h3>Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。<br>（1）请注意！！！ Map 没有继承 Collection 接口， Map 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。 Map 接口提供 3 种集合的视图， Map 的内容可以被当作一组 key 集合，一组 value 集合，或者一组 key-value 映射。<br> （2）Map： </h3><img src=\"/Blog/upload/5252f7c3-f118-4277-a0e1-c715c0bc41e9.png\" style=\"max-width:100%;\"><br></p><h3>（3）HashMap和HashTable的比较：</h3><p><img src=\"/Blog/upload/d73b97b9-3735-493e-8b75-dde09a993953.png\" style=\"max-width:100%;\"><br></p><h3>（4）TreeMap：&nbsp;&nbsp;</h3><p><img src=\"/Blog/upload/16857e9c-ad28-4f79-86c0-94eadefcceba.png\" style=\"font-size: 16.38px; max-width: 100%;\"></p><h3><h3>（5）Map的其它类：&nbsp;</h3><h3>IdentityHashMap和HashMap的具体区别，IdentityHashMap使用 == 判断两个key是否相等，而HashMap使用的是equals方法比较key值。有什么区别呢？<br>对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址。<br>对于equals方法，注意：equals方法不能作用于基本数据类型的变量<br> 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；<br><span style=\"font-size: 16.38px;\">诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。&nbsp;</span><span style=\"font-size: 16.38px;\">&nbsp;<br></span></h3>  <h2><span style=\"font-size: 16.38px;\">（6）小结：&nbsp;</span><span style=\"font-size: 16.38px;\">&nbsp;&nbsp;<br></span></h2><span style=\"font-size: 16.38px;\">HashMap 非线程安全&nbsp;<br></span>HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。<br>适用场景分析：<br> HashMap和HashTable:HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。HashTable同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。<br>HashMap：适用于Map中插入、删除和定位元素。<br> Treemap：适用于按自然顺序或自定义顺序遍历键(key)。<br>5.线程安全集合类与非线程安全集合类<br> LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;<br> HashMap是非线程安全的，HashTable是线程安全的;<br> StringBuilder是非线程安全的，StringBuffer是线程安全的。<br>数据结构<br> ArrayXxx:底层数据结构是数组，查询快，增删慢<br> LinkedXxx:底层数据结构是链表，查询慢，增删快<br> HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()<br> TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</h3><p><span style=\"font-size: 16.38px;\"><br></span></p></div></h5></h3></div>',34,0,'2019-06-02 10:25:59',NULL,'','JAVA基础',1),(4,1,'LeetCode 70.爬楼梯','<p>LeetCode 70.爬楼梯</p><p>假设你正在爬楼梯。需要 n&nbsp;阶你才能到达楼顶。<br><br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><br>注意：给定 n 是一个正整数。<br><br>示例 1：<br></p><pre><code>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶<br>2.  2 阶</code></pre><pre>\n<strong>示例 2：</strong>\n<code>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶 + 1 阶<br>2.  1 阶 + 2 阶<br>3.  2 阶 + 1 阶</code></pre><p><br></p><p>题解：</p><p>设跳n个台阶有f(n)种方法，<br><br>爬1个：1种<br><br>爬2个：2种<br><br>爬n个：面临两种选择：<br><br>（1） 第一次爬1个，此时剩余n-1个台阶，有f(n-1)种方法<br><br>（2） 第一次爬2个，此时剩余n-2个台阶，有f(n-2)种方法<br><br>所以f(n) = f(n-1) + f(n-2)<br><br></p><pre><code>class Solution {<br>    public int climbStairs(int n) {<br>        if(n &lt;= 2){<br>            return n;<br>        }<br>        int num1 =  1;<br>        int num2 = 2;<br>        int numN = 0;<br>        for(int i = 2;i &lt; n;i ++){<br>            numN = num1 + num2;<br>            num1 = num2;<br>            num2 = numN;<br>        }<br>        return numN;<br>    }<br>}<br></code></pre><p><br></p>',3,0,'2019-06-02 13:39:23',NULL,'','算法',1),(5,1,'数据库基础知识','<div>\n                                \n                                </div><h1><span style=\"font-weight: bold;\">123</span><br></h1>',3,0,'2019-06-02 13:40:04',NULL,'','SQL数据库',1),(6,1,'Ajax前后端交互','<div>\n                                \n                                </div><h1><span style=\"font-weight: bold;\">123</span><br></h1>',2,0,'2019-06-02 13:51:09',NULL,'','WEB前端',1),(7,1,'第三方登录——QQ登陆（QQ互联）','<h1><span style=\"text-decoration-line: line-through;\"></span><span style=\"text-decoration-line: line-through;\"></span>一、前言</h1><p><br></p><p>为了优化一下网站的交互，特地学习了一下QQ互联登录的方法</p><p><a href=\"http://wiki.connect.qq.com/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B\" target=\"_blank\">点击我：跳转到官方网站接入流程</a><br></p><p><br></p><h1>二、注册为开发者</h1><p><br></p><p>&nbsp;首先你得成为QQ互联的开发者，你才可以享用它的服务。进入&nbsp;http://connect.qq.com/&nbsp;，选择“网站接入”：</p><p><br></p><p><img src=\"/Blog/upload/a44f611e-378a-4900-b098-368c7dad9e1a.png\" style=\"max-width:100%;\"><br></p><p><br></p><p>然后按流程进行申请</p><p><br></p><p><img src=\"/Blog/upload/459d7d7a-69ef-484d-87f6-373af9a3a86f.png\" style=\"max-width:100%;\"><br></p><p>在申请成功以后，会得到一个AppID和AppKey。</p><p><br></p><h1>三、下载SDK</h1><p><br></p><p>QQ官方提供了一个SDK for Java</p><p>这里提供一个下载地址： https://pan.baidu.com/s/1jRDs-GPV6tny8CZfApbKKw 提取码: uw7j&nbsp;</p><p>下载解压会得到以后文件，这个Demo是用传统\n\nServlet&nbsp; &amp; JSP 做的</p><p><br></p><p><img src=\"/Blog/upload/a087b063-8cdc-4c47-b6f8-538e4e91634f.png\" style=\"max-width:100%;\"><br></p><p><br></p><p>如果是普通项目，直接把jar包导入到项目就好了。</p><p><br></p><h2>如果是maven项目就需要把jar包安装到本地仓库</h2><p>为了方便，我们把Sdk4J.jar放到C:\\Users\\Administrator目录下；<br>然后cmd进入命令行 执行</p><p>&nbsp;<code>mvn install:install-file -DgroupId=com.qq -DartifactId=Sdk4J -Dversion=2 -Dpackaging=jar -Dfile=Sdk4J.jar</code></p><p><p><br></p></p><p><img src=\"/Blog/upload/9c39447d-83ba-43d3-8dc0-665e361bce65.png\" style=\"max-width:100%;\"><br></p><p><br></p><p>然后在maven pom.xml配置：</p><p><br></p><pre><code>&lt;!-- 第三方QQ登录 --&gt;<br>      &lt;dependency&gt;<br>        &lt;groupId&gt;com.qq&lt;/groupId&gt;<br>        &lt;artifactId&gt;Sdk4J&lt;/artifactId&gt;<br>        &lt;version&gt;2&lt;/version&gt;<br>      &lt;/dependency&gt;</code></pre><p><br></p><h1>四、后台配置</h1><p><br></p><p>1、qqconnectconfig.properties配置文件，按你申请得到的来填写</p><p><img src=\"/Blog/upload/83b5459d-69b3-4060-9a72-e96c6c75af95.png\" style=\"max-width:100%;\"><br></p><p><br></p><p>2、跳转到登录方法，会根据Oauth2.0协议规范调，调用getAuthorizeURL方法return返回authorizeURL，并带上相应参数<br></p><p><br></p><pre><code>@RequestMapping(\"/qqlogin\")<br>    public void QQLogin(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>        response.setContentType(\"text/html;charset=utf-8\");<br>        try {<br>            /* String authorizeURL = new Oauth().getAuthorizeURL(request);*/<br>            response.sendRedirect(new Oauth().getAuthorizeURL(request));<br>        } catch (QQConnectException e) {<br>            e.printStackTrace();<br>        }<br>    }</code></pre><p><br></p><p>3、根据返回的返回authorizeURL，跳到指定的回调地址</p><p><br></p><pre><code>@RequestMapping(value = \"/afterqqlogin\",method= RequestMethod.GET)<br>    public String AfterQQLogin(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>        try {<br>            AccessToken accessTokenObj = (new Oauth()).getAccessTokenByRequest(request);<br>            String accessToken   = null,<br>                    openID        = null;<br>            long tokenExpireIn = 0L;<br>            if (accessTokenObj.getAccessToken().equals(\"\")) {<br>                System.out.print(\"没有获取到响应参数\");<br>            }else{<br>                accessToken = accessTokenObj.getAccessToken();<br>                tokenExpireIn = accessTokenObj.getExpireIn();<br>                OpenID openIDObj =  new OpenID(accessToken);<br>                openID = openIDObj.getUserOpenID();<br>                UserInfo qzoneUserInfo = new UserInfo(accessToken, openID);<br>                UserInfoBean userInfoBean = qzoneUserInfo.getUserInfo();<br>                HttpSession session=request.getSession();<br>                session.setAttribute(\"name\", userInfoBean.getNickname());<br>                session.setAttribute(\"avatar\", userInfoBean.getAvatar().getAvatarURL30());<br><br>            }<br>        }catch(Exception e){<br>            e.printStackTrace();<br>        }<br>        return \"Home/qq\";<br>    }</code></pre><p><br></p><h1>四、JSP配置</h1><p><br></p><p>在JSP中加入QQ登录图标的链接。</p><p><br></p><pre><code>&lt;a href=\"qqlogin\"&gt;&lt;img src=\"images/qq_32.png\"&gt;&lt;/a&gt;\n</code></pre><p><br></p><p><img src=\"/Blog/upload/bae5aa4c-e68f-40a6-8bdd-fcbf00d4d3c8.png\" style=\"max-width:100%;\"><br></p><p><br></p><p>QQ登录成功后的JSP：</p><p><br></p><pre><code>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;p&gt;欢迎${sessionScope.name}&lt;/p&gt;<br>&lt;img alt=\"\" src=\"${sessionScope.avatar}\"&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>',9,0,'2019-06-02 13:52:17',NULL,'','JAVA后端',1),(8,1,'第三方登录——微信登陆','<div>\n                                <div>\n                                \n                                </div><h1><b>在申请开发者的时候，显示系统错误，找不到原因，有空再弄吧。</b></h1>\n                                </div><p><br></p>',4,0,'2019-06-02 13:52:28',NULL,'','JAVA后端',1),(9,1,'Blog1.0上线啦！！！！','<p>经过努力<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/pcmoren_wu_org.png\" alt=\"[污]\"></p><p>1.0版本上线了<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/40/pcmoren_tian_org.png\" alt=\"[舔屏]\"></p><p>还是有挺多模块没有实现的<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/50/pcmoren_huaixiao_org.png\" alt=\"[坏笑]\"></p><p>待我慢慢努力完善?</p>',4,0,'2019-06-02 13:54:24',NULL,'','杂文随笔',1),(10,1,'session和Cookie的区别与使用','<div>\n                                \n                                </div><h1><span style=\"font-weight: bold;\">123</span><br></h1>',4,0,'2019-06-02 13:55:09',NULL,'','JAVA后端',1),(11,1,'TCP协议详解','<div>\n                                <div>\n                                <div>\n                                \n                                <div>\n                                \n                                </div><h1 id=\"udp-和-tcp-的特点\"></h1><h1>UDP 和 TCP 的特点</h1><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li><br></li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li><li><br></li></ul></div><h1>UDP 首部格式</h1><p><img src=\"/Blog/upload/95d3ae53-d353-4be0-ad48-9a73e7979cd6.jpg\" style=\"max-width:100%;\"><br></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。&nbsp;</p><p><br></p><h1>TCP 首部格式&nbsp;</h1><p><img src=\"/Blog/upload/16af9d7a-a002-4682-a4a3-8efd2a452186.png\" style=\"max-width:100%;\"><br></p><p><br></p><ol><li><span style=\"font-weight: bold;\">序号：</span>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><p><span style=\"font-weight: bold;\">确认号&nbsp;</span>：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><span style=\"font-weight: bold;\">数据偏移&nbsp;</span>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><span style=\"font-weight: bold;\">确认 ACK</span>&nbsp;：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><span style=\"font-weight: bold;\">同步 SYN&nbsp;</span>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong>&nbsp;：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。&nbsp;</p></li><li><strong>窗口</strong>&nbsp;：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。&nbsp;&nbsp;</li></ol><p><br></p><h1>TCP 的三次握手</h1><p><img src=\"/Blog/upload/47e590a0-8a1e-4d7f-894f-0484d2a39945.png\" style=\"max-width:100%;\"></p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。<br></p><ol><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ol><p><strong>三次握手的原因</strong>&nbsp;</p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><br></p><h1>TCP 的四次挥手&nbsp;</h1><p><img src=\"/Blog/upload/1e20ea12-9939-42e1-b45d-9e9c7686b593.jpg\" style=\"max-width:100%;\"><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ol><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li><li><br></li></ol><p><strong>四次挥手的原因</strong>&nbsp;</p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><br></p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><p>&nbsp;<br></p><h1>TCP 滑动窗口</h1><div><br></div><div><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p><br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p><br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p></div>\n                                </div><p><img src=\"/Blog/upload/019a0c18-9b4e-43d5-a855-0820d811e440.jpg\" style=\"max-width:100%;\"><br></p><p><br></p><h1>TCP 流量控制</h1><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p><br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。<br></p><p><br></p><h1>TCP 拥塞控制</h1><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。&nbsp;&nbsp;<br></p><p>&nbsp;&nbsp;<br></p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p><br>为了便于讨论，做如下假设：<br></p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src=\"/Blog/upload/1b7812cb-3892-47bd-bdb0-18110528f660.png\" style=\"max-width:100%;\"><br></p><p><br></p><h2>1. 慢开始与拥塞避免</h2><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p><p><br>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p><br>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。<br></p><p><br></p><h2>2. 快重传与快恢复</h2><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1&nbsp;和 M2，此时收到 M4，应当发送对 M2&nbsp;的确认。</p><p><br>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3&nbsp;丢失，立即重传 M3。</p><p><br></p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p><br>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src=\"/Blog/upload/f6b7934a-36ed-4684-9c87-0cecd566787a.png\" style=\"max-width:100%;\"><br></p><p><br></p><p><br></p>\n                                </div><p><br></p>',72,0,'2019-06-02 13:55:51',NULL,'','计算机网络',1),(12,1,'TCP/IP协议簇与OSI参考模型','<h1>OSI参考模型</h1><p><img src=\"/Blog/upload/49eecaf2-bfa3-40e8-aa31-13fead9eb3c8.png\" style=\"max-width:100%;\"><br></p><p><br></p><h2>各层小结</h2><p><img src=\"/Blog/upload/99a5a0ea-e072-43c2-9c2b-8f85402d7eb2.png\" style=\"max-width:100%;\"><br></p><p><br></p><h1>分层的好处</h1><ol><li>提供更为模块化的设计，灵活性强</li><li>结构上可分开</li><li>方便实现和维护</li><li>有利于标准化</li></ol><p><br></p><h1>TCP/IP协议簇的层次结构</h1><p><img src=\"/Blog/upload/db3e1bc0-9cc8-4422-aed1-d0ef62028da9.png\" style=\"max-width:100%;\"><br></p><p><br></p><p><br></p>',3,0,'2019-06-13 23:07:08',NULL,'','计算机网络',1),(13,1,'[转载] JAVA实现八大排序法','<div>\n                                <div>\n                                \n                                </div><h1>各排序法性能比较</h1><p><img src=\"/Blog/upload/7e004510-cf99-46a9-b2c6-22a4424769bc.png\" style=\"max-width: 100%;\">&nbsp;</p><p><br></p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/1156494-ab4cecff133d87b3.png\" alt=\"\" title=\"\"></p><h2><br></h2><h2>一、直接插入排序（Insertion Sort）</h2><div><br></div><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p><br></p><p>插入排序由于操作不尽相同, 可分为&nbsp;<code>直接插入排序</code>&nbsp;,&nbsp;<code>折半插入排序</code>(又称二分插入排序),&nbsp;<code>链表插入排序</code>&nbsp;,&nbsp;<code>希尔排序</code>&nbsp;。我们先来看下直接插入排序。</p><p><br></p><h4 id=\"1基本思想\">1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/Insertion-sort-example-300px.gif\" alt=\"使用插入排序为一列数字进行排序的过程\" title=\"\"></p><p><br></p><h4 id=\"2算法描述\">2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序&nbsp;<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描&nbsp;<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置&nbsp;<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&nbsp;<br>⑤. 将新元素插入到该位置后&nbsp;<br>⑥. 重复步骤②~⑤</p><p><br></p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif\" alt=\"直接插入排序演示\" title=\"\"></p><p><br></p><p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95\" rel=\"nofollow\" target=\"_blank\">二分查找法</a>来减少<em>比较操作</em>的数目。该算法可以认为是<strong>插入排序</strong>的一个变种，称为<a href=\"https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1\" rel=\"nofollow\" target=\"_blank\">二分查找插入排序</a>。</p><p><br></p><h4 id=\"3代码实现\">3、代码实现</h4><div><br></div><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">    /**\n     * 插入排序\n     *\n     * 1. 从第一个元素开始，该元素可以认为已经被排序\n     * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n     * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n     * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n     * 5. 将新元素插入到该位置后\n     * 6. 重复步骤2~5\n     * @param arr  待排序数组\n     */\n    public static void insertionSort(int[] arr){\n        for( int i=0; i&lt;arr.length-1; i++ ) {\n            for( int j=i+1; j&gt;0; j-- ) {\n                if( arr[j-1] &lt;= arr[j] )\n                    break;\n                int temp = arr[j];      //交换操作\n                arr[j] = arr[j-1];\n                arr[j-1] = temp;\n                System.out.println(\"Sorting:  \" + Arrays.toString(arr));\n            }\n        }\n    }</code><ul><li><br></li></ul></pre><p>直接插入排序复杂度如下：</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><br></div><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h2><br>二、希尔排序（Shell Sort）</h2><h3 id=\"二希尔排序shell-sort\"><a name=\"t3\"></a></h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p><br></p><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p><br></p><h4 id=\"1基本思想-1\">1、基本思想</h4><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg\" alt=\"\" title=\"\"></p><p><br></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97\" rel=\"nofollow\" target=\"_blank\">维基百科</a>。</p><p><br></p><h4 id=\"2算法描述-1\">2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）&nbsp;<br>②. 按增量序列个数k，对序列进行k 趟排序；&nbsp;<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><br></p><h4 id=\"3代码实现-1\">3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 希尔排序\n *\n * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）\n * 2. 按增量序列个数k，对序列进行k 趟排序；\n * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。\n *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n * @param arr  待排序数组\n */\npublic static void shellSort(int[] arr){\n    int gap = arr.length / 2;\n    for (; gap &gt; 0; gap /= 2) {      //不断缩小gap，直到1为止\n        for (int j = 0; (j+gap) &lt; arr.length; j++){     //使用当前gap进行组内插入排序\n            for(int k = 0; (k+gap)&lt; arr.length; k += gap){\n                if(arr[k] &gt; arr[k+gap]) {\n                    int temp = arr[k+gap];      //交换操作\n                    arr[k+gap] = arr[k];\n                    arr[k] = temp;\n                    System.out.println(\"    Sorting:  \" + Arrays.toString(arr));\n                }\n            }\n        }\n    }\n}</code><ul><li><br></li></ul></pre><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 希尔排序（Wiki官方版）\n *\n * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）\n * 2. 按增量序列个数k，对序列进行k 趟排序；\n * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。\n *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n * @param arr  待排序数组\n */\npublic static void shell_sort(int[] arr) {\n    int gap = 1, i, j, len = arr.length;\n    int temp;\n    while (gap &lt; len / 3)\n        gap = gap * 3 + 1;      // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...\n    for (; gap &gt; 0; gap /= 3) {\n        for (i = gap; i &lt; len; i++) {\n            temp = arr[i];\n            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)\n                arr[j + gap] = arr[j];\n            arr[j + gap] = temp;\n        }\n    }\n}</code><ul><li><br></li></ul></pre><p>以下是希尔排序复杂度:</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(1)</td></tr></tbody></table><br></div><h2>三、选择排序（Selection Sort）</h2><h3 id=\"三选择排序selection-sort\"><a name=\"t4\"></a></h3><hr><blockquote><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif\" alt=\"选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。\" title=\"\"></p></blockquote><p><br></p><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><p><br></p><h4 id=\"1基本思想-2\">1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><p><br></p><h4 id=\"2算法描述-2\">2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；&nbsp;<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；&nbsp;<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p><p><br></p><h4 id=\"3代码实现-2\">3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 选择排序\n *\n * 1. 从待排序序列中，找到关键字最小的元素；\n * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；\n * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。\n *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n * @param arr  待排序数组\n */\npublic static void selectionSort(int[] arr){\n    for(int i = 0; i &lt; arr.length-1; i++){\n        int min = i;\n        for(int j = i+1; j &lt; arr.length; j++){    //选出之后待排序中值最小的位置\n            if(arr[j] &lt; arr[min]){\n                min = j;\n            }\n        }\n        if(min != i){\n            int temp = arr[min];      //交换操作\n            arr[min] = arr[i];\n            arr[i] = temp;\n            System.out.println(\"Sorting:  \" + Arrays.toString(arr));\n        }\n    }\n}</code><ul><li><br></li></ul></pre><p>以下是选择排序复杂度:</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table></div><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><p><br></p><h2>四、堆排序（Heap Sort）</h2><h3 id=\"四堆排序heap-sort\"><a name=\"t5\"></a></h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：n个元素的序列{k1,k2,···,kn}，当且仅当满足下关系时，称之为堆。</p><p>ki &lt;= k(2i) &nbsp;且 &nbsp; ki &lt;= k(2i+1)</p><p>或： &nbsp; ki &gt;= k(2i) 且 ki &gt;= k(2i+1)</p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><p><br></p><h4 id=\"1基本思想-3\">1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><p><br></p><h4 id=\"2算法描述-3\">2、算法描述</h4><p>①. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.&nbsp;<br>②. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n-1]和有序区K[n], 且满足K[1..n-1].keys &lt;= K[n].key&nbsp;<br>③. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n-1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p><p>动图效果如下所示：</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/heap_sort_gif.gif\" alt=\"堆排序过程\" title=\"\"></p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif\" alt=\"堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。\" title=\"\"></p><p><br></p><h4 id=\"3代码实现-3\">3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p><br></p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li><li><br></li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li><li><br></li></ul><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 堆排序\n *\n * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.\n * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key\n * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.\n * @param arr  待排序数组\n */\npublic static void heapSort(int[] arr){\n    for(int i = arr.length; i &gt; 0; i--){\n        max_heapify(arr, i);\n\n        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换\n        arr[0] = arr[i-1];\n        arr[i-1] = temp;\n    }\n}\n\nprivate static void max_heapify(int[] arr, int limit){\n    if(arr.length &lt;= 0 || arr.length &lt; limit) return;\n    int parentIdx = limit / 2;\n\n    for(; parentIdx &gt;= 0; parentIdx--){\n        if(parentIdx * 2 &gt;= limit){\n            continue;\n        }\n        int left = parentIdx * 2;       //左子节点位置\n        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置\n\n        int maxChildId = arr[left] &gt;= arr[right] ? left : right;\n        if(arr[maxChildId] &gt; arr[parentIdx]){   //交换父节点与左右子节点中的最大值\n            int temp = arr[parentIdx];\n            arr[parentIdx] = arr[maxChildId];\n            arr[maxChildId] = temp;\n        }\n    }\n    System.out.println(\"Max_Heapify: \" + Arrays.toString(arr));\n}</code><ul><li><br></li></ul></pre><blockquote><p><strong>注:</strong>&nbsp;x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</p></blockquote><p><br></p><p>以上,&nbsp;<br>①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);&nbsp;<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);&nbsp;<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><p><br></p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table></div><p>Tips:&nbsp;<strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong>&nbsp;同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><p><br></p><h2>五、冒泡排序（Bubble Sort）</h2><h3 id=\"五冒泡排序bubble-sort\"><a name=\"t6\"></a></h3><hr><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif\" alt=\"冒泡排序的思想\" title=\"\"></p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id=\"1基本思想-4\"><br></h4><h4 id=\"1基本思想-4\">1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><br></p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif\" alt=\"冒泡排序演示\" title=\"\"></p><p><br></p><h4 id=\"2算法描述-4\">2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。&nbsp;<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&nbsp;<br>③. 针对所有的元素重复以上的步骤，除了最后一个。&nbsp;<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p><p><br></p><h4 id=\"3代码实现-4\">3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中,&nbsp;<strong>外层循环</strong>移动游标;&nbsp;<strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 冒泡排序\n *\n * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n * ③. 针对所有的元素重复以上的步骤，除了最后一个。\n * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。\n * @param arr  待排序数组\n */\npublic static void bubbleSort(int[] arr){\n    for (int i = arr.length - 1; i &gt; 0; i--) {      //外层循环移动游标\n        for(int j = 0; j &lt; i; j++){    //内层循环遍历游标及之后(或之前)的元素\n            if(arr[j] &gt; arr[j+1]){\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                System.out.println(\"Sorting: \" + Arrays.toString(arr));\n            }\n        }\n    }\n}</code><ul><li><br></li></ul></pre><p>以下是冒泡排序算法复杂度:</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table></div><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><p><br></p><h2>六、快速排序（Quick Sort）</h2><h3 id=\"六快速排序quick-sort\"><a name=\"t7\"></a></h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><p><br></p><h4 id=\"1基本思想-5\">1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif\" alt=\"使用快速排序法对一列数字进行排序的过程\" title=\"\"></p><p><br></p><h4 id=\"2算法描述-5\">2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。&nbsp;<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。&nbsp;<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p><br></p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif\" alt=\"快速排序演示\" title=\"\"></p><p><br></p><h4 id=\"3代码实现-5\">3、代码实现</h4><p>用伪代码描述如下：</p><p>①.&nbsp;<code>i = L; j = R;</code>&nbsp;将基准数挖出形成第一个坑<code>a[i]</code>。&nbsp;<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。&nbsp;<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。&nbsp;<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p><p><br></p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png\" alt=\"快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。\" title=\"\"></p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 快速排序（递归）\n *\n * ①. 从数列中挑出一个元素，称为\"基准\"（pivot）。\n * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n * @param arr   待排序数组\n * @param low   左边界\n * @param high  右边界\n */\npublic static void quickSort(int[] arr, int low, int high){\n    if(arr.length &lt;= 0) return;\n    if(low &gt;= high) return;\n    int left = low;\n    int right = high;\n\n    int temp = arr[left];   //挖坑1：保存基准的值\n    while (left &lt; right){\n        while(left &lt; right &amp;&amp; arr[right] &gt;= temp){  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中\n            right--;\n        }\n        arr[left] = arr[right];\n        while(left &lt; right &amp;&amp; arr[left] &lt;= temp){   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中\n            left++;\n        }\n        arr[right] = arr[left];\n    }\n    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排\n    System.out.println(\"Sorting: \" + Arrays.toString(arr));\n    quickSort(arr, low, left-1);\n    quickSort(arr, left+1, high);\n}</code><ul><li><br></li></ul></pre><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 快速排序（非递归）\n *\n * ①. 从数列中挑出一个元素，称为\"基准\"（pivot）。\n * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤\n * @param arr   待排序数组\n */\npublic static void quickSortByStack(int[] arr){\n    if(arr.length &lt;= 0) return;\n    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\n\n    //初始状态的左右指针入栈\n    stack.push(0);\n    stack.push(arr.length - 1);\n    while(!stack.isEmpty()){\n        int high = stack.pop();     //出栈进行划分\n        int low = stack.pop();\n\n        int pivotIdx = partition(arr, low, high);\n\n        //保存中间变量\n        if(pivotIdx &gt; low) {\n            stack.push(low);\n            stack.push(pivotIdx - 1);\n        }\n        if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0){\n            stack.push(pivotIdx + 1);\n            stack.push(high);\n        }\n    }\n}\n\nprivate static int partition(int[] arr, int low, int high){\n    if(arr.length &lt;= 0) return -1;\n    if(low &gt;= high) return -1;\n    int l = low;\n    int r = high;\n\n    int pivot = arr[l];    //挖坑1：保存基准的值\n    while(l &lt; r){\n        while(l &lt; r &amp;&amp; arr[r] &gt;= pivot){  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中\n            r--;\n        }\n        arr[l] = arr[r];\n        while(l &lt; r &amp;&amp; arr[l] &lt;= pivot){   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中\n            l++;\n        }\n        arr[r] = arr[l];\n    }\n    arr[l] = pivot;   //基准值填补到坑3中，准备分治递归快排\n    return l;\n}</code><ul><li><br></li></ul></pre><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p><br></p><p>以下是快速排序算法复杂度:</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)（原地分区递归版）</td></tr></tbody></table><br></div><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><p><br></p><h2>七、归并排序（Merging Sort）</h2><h3 id=\"七归并排序merging-sort\"><a name=\"t8\"></a></h3><hr><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg\" alt=\"\" title=\"\"></p><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><p><br></p><h4 id=\"1基本思想-6\">1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" alt=\"这个图很有概括性，来自维基\" title=\"\"></p><p><br></p><h4 id=\"2算法描述-6\">2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li><li><br></li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；&nbsp;<br>②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；&nbsp;<br>③. 重复步骤②，直到所有元素排序完毕。</p><p><br></p><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif\" alt=\"\" title=\"\"></p><p><br></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&nbsp;<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置&nbsp;<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&nbsp;<br>④. 重复步骤③直到某一指针到达序列尾&nbsp;<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p><p><br></p><h4 id=\"3代码实现-6\">3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><br></p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]&nbsp;<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]&nbsp;<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p><p><br></p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列&nbsp;<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><p><br></p><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 归并排序（递归）\n *\n * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；\n * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；\n * ③. 重复步骤②，直到所有元素排序完毕。\n * @param arr    待排序数组\n */\npublic static int[] mergingSort(int[] arr){\n    if(arr.length &lt;= 1) return arr;\n\n    int num = arr.length &gt;&gt; 1;\n    int[] leftArr = Arrays.copyOfRange(arr, 0, num);\n    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);\n    System.out.println(\"split two array: \" + Arrays.toString(leftArr) + \" And \" + Arrays.toString(rightArr));\n    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并\n}\n\nprivate static int[] mergeTwoArray(int[] arr1, int[] arr2){\n    int i = 0, j = 0, k = 0;\n    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组\n    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length){      //选取两个序列中的较小值放入新数组\n        if(arr1[i] &lt;= arr2[j]){\n            result[k++] = arr1[i++];\n        }else{\n            result[k++] = arr2[j++];\n        }\n    }\n    while(i &lt; arr1.length){     //序列1中多余的元素移入新数组\n        result[k++] = arr1[i++];\n    }\n    while(j &lt; arr2.length){     //序列2中多余的元素移入新数组\n        result[k++] = arr2[j++];\n    }\n    System.out.println(\"Merging: \" + Arrays.toString(result));\n    return result;\n}</code><ul><li><br></li></ul></pre><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p><strong><br></strong></p><p>以下是归并排序算法复杂度:</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td></tr></tbody></table><br></div><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id=\"八基数排序radix-sort\"><br></h3><h2>八、基数排序（Radix Sort）</h2><h3 id=\"八基数排序radix-sort\"><a name=\"t9\"></a></h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><br></p><h4 id=\"1基本思想-7\">1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p><br></p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p></li><li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p></li><li><p><br></p></li></ul><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif\" alt=\"基数排序LSD动图演示\" title=\"\"></p><p><br></p><h4 id=\"2算法描述-7\">2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；&nbsp;<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；&nbsp;<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><p><br></p><h4 id=\"3代码实现-7\">3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p></li><li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p></li><li><p><br></p></li></ul><pre name=\"code\"><code onclick=\"mdcp.copyCode(event)\">/**\n * 基数排序（LSD 从低位开始）\n *\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n *\n * ①. 取得数组中的最大数，并取得位数；\n * ②. arr为原始数组，从最低位开始取每个位组成radix数组；\n * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n * @param arr    待排序数组\n */\npublic static void radixSort(int[] arr){\n    if(arr.length &lt;= 1) return;\n\n    //取得数组中的最大数，并取得位数\n    int max = 0;\n    for(int i = 0; i &lt; arr.length; i++){\n        if(max &lt; arr[i]){\n            max = arr[i];\n        }\n    }\n    int maxDigit = 1;\n    while(max / 10 &gt; 0){\n        maxDigit++;\n        max = max / 10;\n    }\n    System.out.println(\"maxDigit: \" + maxDigit);\n\n    //申请一个桶空间\n    int[][] buckets = new int[10][arr.length];\n    int base = 10;\n\n    //从低位到高位，对每一位遍历，将所有元素分配到桶中\n    for(int i = 0; i &lt; maxDigit; i++){\n        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量\n\n        //分配：将所有元素分配到桶中\n        for(int j = 0; j &lt; arr.length; j++){\n            int whichBucket = (arr[j] % base) / (base / 10);\n            buckets[whichBucket][bktLen[whichBucket]] = arr[j];\n            bktLen[whichBucket]++;\n        }\n\n        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞\n        int k = 0;\n        for(int b = 0; b &lt; buckets.length; b++){\n            for(int p = 0; p &lt; bktLen[b]; p++){\n                arr[k++] = buckets[b][p];\n            }\n        }\n\n        System.out.println(\"Sorting: \" + Arrays.toString(arr));\n        base *= 10;\n    }\n}</code><ul><li><br></li></ul></pre><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><div><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><br></div><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为&nbsp;<code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><br></p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li><li><br></li></ol><h2>总结</h2><h3 id=\"总结\"><a name=\"t10\"></a></h3><hr><p>各种排序性能对比如下图，有些排序未详细介绍，暂且放到这里。&nbsp;<br>实例测试结果可以看这里：<a href=\"https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md\" rel=\"nofollow\" target=\"_blank\"><strong>八大排序算法耗时对比</strong></a>&nbsp;。</p><p><br></p><div><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr><tr><td>基数排序</td><td>O(d(n+k))</td><td>O(d(n+k))</td><td>O(d(n+kd))</td><td>O(n+kd)</td><td>稳定</td></tr></tbody></table><br></div><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：<strong><code>各类简单排序：直接插入、直接选择和冒泡排序</code></strong>；</p><p>(2). 线性对数阶O(nlog₂n)排序：<strong><code>快速排序、堆排序和归并排序</code></strong>；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：<strong><code>希尔排序</code></strong></p><p>(4). 线性阶O(n)排序：<strong><code>基数排序，此外还有桶、箱排序</code></strong>。</p><p><br></p><h4 id=\"时间复杂度极限\">时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值</li><li>桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li><li><br></li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O(nlgn)</strong>。 参考<a href=\"https://www.zhihu.com/question/24516934\" rel=\"nofollow\" target=\"_blank\">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><p><br></p><h4 id=\"说明\">说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src=\"https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png\" alt=\"\" title=\"\"></p><p><br></p><p><br></p><p>&nbsp;<br></p>\n                                </div><p><br></p>',7,0,'2019-06-14 09:31:12',NULL,'','算法',1),(16,1,'Linux常用操作指令','<div>\n                                \n                                </div><h1>列出目录内容&nbsp; &nbsp; &nbsp; ls(list)</h1><p><br></p><p>格式： ls [参数]&nbsp; [文件/文件目录]&nbsp; &nbsp;</p><blockquote>ls&nbsp; -l&nbsp; 简写： ll</blockquote><p><br></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><h3><span style=\"font-weight: normal;\">&nbsp;-a/-all</span></h3></th><th><h3><span style=\"font-weight: normal;\">&nbsp;所有文件/目录</span></h3></th></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-l</h3></td><td style=\"text-align: center;\"><h3>&nbsp;使用详细格式列表</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-t</h3></td><td style=\"text-align: center;\"><h3>&nbsp;时间排序</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-r</h3></td><td style=\"text-align: center;\"><h3>&nbsp;反向排序</h3></td></tr></tbody></table><p><br></p><h1>切换目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>cd(change directory)</h1><p style=\"text-align: center;\"><br></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"text-align: center;\"><tbody><tr><th><h3>&nbsp;<span style=\"font-weight: normal;\">cd&nbsp; ~</span></h3></th><th><h3><span style=\"font-weight: normal;\">当前用户目录&nbsp;</span></h3></th></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;cd /</h3></td><td><h3>&nbsp;根目录</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;cd -</h3></td><td><h3>&nbsp;上一次访问目录</h3></td></tr><tr><td><h3>&nbsp;cd ..</h3></td><td><h3>&nbsp;上一级目录</h3></td></tr></tbody></table><p style=\"text-align: center;\"><br></p><h1 style=\"text-align: left;\">显示当前工作目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>pwd(print work directory)</h1><p><br></p><h1>创建目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>mkdir(make directory)</h1><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><h3><span style=\"font-weight: normal;\">-p&nbsp;</span></h3></th><th><h3><span style=\"font-weight: normal;\">父目录不存在的情况下先生成目录&nbsp;</span></h3></th></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-v</h3></td><td style=\"text-align: center;\"><h3>&nbsp;显示命令执行过程中的详情</h3></td></tr></tbody></table><p><br></p><h1 style=\"text-align: left;\">显示文本内容&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>cat(catenate)</h1><blockquote>cat[文本]</blockquote><p><br></p><h1>分页显示文件内容&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>more</h1><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><h3>&nbsp;<span style=\"font-weight: normal;\">Enter</span></h3></th><th><h3><span style=\"font-weight: normal;\">向下n行&nbsp; &nbsp;</span></h3></th></tr><tr><td style=\"text-align: center;\"><h3>空格键/Ctrl+下</h3></td><td style=\"text-align: center;\"><h3>&nbsp;向下滚动一屏</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;B</h3></td><td style=\"text-align: center;\"><h3>&nbsp;向上滚动一屏</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;q</h3></td><td style=\"text-align: center;\"><h3>&nbsp;退出more</h3></td></tr></tbody></table><p><br></p><h1>分页显示文件内容，操作更详细&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>less</h1><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"text-align: center;\"><tbody><tr><th><h3><span style=\"font-weight: normal;\">-m&nbsp;&nbsp;</span>\n\n<span style=\"font-weight: normal;\">&nbsp;-n</span></h3></th><th><h3><span style=\"font-weight: normal;\">显示类似more命令的百分比&nbsp;&nbsp;</span>\n\n<span style=\"font-weight: normal;\">显示每行的行号</span></h3></th></tr><tr><td><h3>q</h3></td><td><h3>退出</h3></td></tr><tr><td><h3>&nbsp;空格键/b</h3></td><td><h3>前进/后退一页</h3></td></tr><tr><td><h3>&nbsp;d/u</h3></td><td><h3>前进/后退半夜</h3></td></tr><tr><td><h3>&nbsp;回车键、↑/ y、↓</h3></td><td><h3>前进/后退一页</h3></td></tr><tr><td><h3>/&nbsp; ？&nbsp;</h3></td><td><h3>向下/向上搜索&nbsp;&nbsp;</h3></td></tr><tr><td><h3>V</h3></td><td><h3>进入vim编辑器模式&nbsp;</h3></td></tr></tbody></table><p><div style=\"text-align: center;\"><br></div><h3>vim 文件名：</h3><h1><img src=\"/Blog/upload/be6e74f4-bc2e-422a-81fb-231eb9e00b0a.png\" style=\"max-width:100%;\"><br></h1><h1><br></h1><h1>查看文件后X行内容&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>tail -数字 文件名</h1></p><blockquote>tail -10 index.jsp</blockquote><p><br></p><h1>复制文件或目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>cp(copy)</h1><p>cp [参数] [源文件/目录] [目标文件/目录]</p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><h3><span style=\"font-weight: normal;\">-r/-recursive&nbsp;</span></h3></th><th><h3><span style=\"font-weight: normal;\">递归处理&nbsp;</span></h3></th></tr></tbody></table><p><br></p><h1>删除文件/目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>rm(remove)</h1><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><h3><span style=\"font-weight: normal;\">&nbsp;rm 文件名</span></h3></th><th><h3><span style=\"font-weight: normal;\">删除文件&nbsp;</span></h3></th></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-r</h3></td><td style=\"text-align: center;\"><h3>递归&nbsp;</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;-f</h3></td><td style=\"text-align: center;\"><h3>强制删除&nbsp;</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;rm -rf 目录名</h3></td><td style=\"text-align: center;\"><h3>删除目录&nbsp;</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;rm -rf *</h3></td><td style=\"text-align: center;\"><h3>删除目录下所有内容&nbsp;</h3></td></tr><tr><td style=\"text-align: center;\"><h3>&nbsp;rm -rf /*</h3></td><td style=\"text-align: center;\"><h3>删除Linux系统根目录下所有内容&nbsp;</h3></td></tr></tbody></table><p><br></p><h1>查找文件或者目录&nbsp; &nbsp; &nbsp;<span style=\"font-size: 14px;\">&nbsp;</span>find</h1><p><br><blockquote>find 目录名 -name\'需要查找的字符串\'&nbsp;&nbsp;</blockquote></p><p><br></p><h2>find /root -name\'*.jsp\'&nbsp;</h2><p><br></p><p><br></p><h1>未完待续。。。有点累了<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/pcmoren_wu_org.png\" alt=\"[污]\" data-w-e=\"1\" style=\"font-size: 14px;\"></h1><h1><br></h1><p><br></p><p><br></p>',1,0,'2019-06-16 22:24:00',NULL,'','JAVA后端',1);
INSERT INTO `article` VALUES (17,1,'网际协议（IP）','<div>\n                                \n                                </div><h1>一、概述</h1><p>IP是一种不可靠的无连接的数据包协议——尽最大努力服务</p><p><br></p><p>尽最大努力一词的意思是IP不提供差错检验或跟踪</p><p><br></p><p>IP假定了底层是不可靠的，因此尽最大努力传输到终点，但没有保证</p><p><br></p><h1>二、数据报</h1><p>在IP层的分组叫数据报，格式如下：</p><p><img src=\"/Blog/upload/47847312-8fc3-4b33-919a-e261b5e8b2a1.png\" style=\"max-width:100%;\"><br></p><p><br></p><h2><blockquote>服务类型</blockquote></h2><p><br></p><p><style>\n<!--tr\n\t{mso-height-source:auto;}\ncol\n\t{mso-width-source:auto;}\ntd\n\t{padding-top:1.0px;\n\tpadding-right:1.0px;\n\tpadding-left:1.0px;\n\tmso-ignore:padding;\n\tcolor:windowtext;\n\tfont-size:18.0pt;\n\tfont-weight:400;\n\tfont-style:normal;\n\ttext-decoration:none;\n\tfont-family:Arial;\n\tmso-generic-font-family:auto;\n\tmso-font-charset:0;\n\ttext-align:general;\n\tvertical-align:bottom;\n\tborder:none;\n\tmso-background-source:auto;\n\tmso-pattern:auto;}\n.oa1\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa2\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa3\n\t{border-top:2.25pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa4\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa5\n\t{border:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa6\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa7\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa8\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa9\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n-->\n</style>\n\n\n\n\n\n</p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"907\" style=\"width: 680pt;\">\n <colgroup><col width=\"156\">\n <col width=\"290\">\n <col width=\"182\">\n <col width=\"280\">\n </colgroup><tbody><tr height=\"96\">\n  <td height=\"96\" class=\"oa1\" width=\"156\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TOS</span><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">位</span></p>\n  </td>\n  <td class=\"oa2\" width=\"290\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">说&nbsp; 明</span></p>\n  </td>\n  <td class=\"oa2\" width=\"182\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TOS</span><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">位</span></p>\n  </td>\n  <td class=\"oa3\" width=\"280\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">说&nbsp; 明</span></p>\n  </td>\n </tr>\n <tr height=\"97\">\n  <td height=\"97\" class=\"oa4\" width=\"156\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0000</span></p>\n  </td>\n  <td class=\"oa5\" width=\"290\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">正常（默认）</span></p>\n  </td>\n  <td class=\"oa5\" width=\"182\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0100</span></p>\n  </td>\n  <td class=\"oa6\" width=\"280\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最大吞吐量</span></p>\n  </td>\n </tr>\n <tr height=\"96\">\n  <td height=\"96\" class=\"oa4\" width=\"156\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0001</span></p>\n  </td>\n  <td class=\"oa5\" width=\"290\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小代价</span></p>\n  </td>\n  <td class=\"oa5\" width=\"182\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"280\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"96\">\n  <td height=\"96\" class=\"oa7\" width=\"156\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0010</span></p>\n  </td>\n  <td class=\"oa8\" width=\"290\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 32pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最高可靠性</span></p>\n  </td>\n  <td class=\"oa8\" width=\"182\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"></p>\n  </td>\n  <td class=\"oa9\" width=\"280\">\n  <p style=\"line-height: normal; margin: 7.68pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"></p>\n  </td>\n </tr>\n</tbody></table><br><p><style>\n<!--tr\n\t{mso-height-source:auto;}\ncol\n\t{mso-width-source:auto;}\ntd\n\t{padding-top:1.0px;\n\tpadding-right:1.0px;\n\tpadding-left:1.0px;\n\tmso-ignore:padding;\n\tcolor:windowtext;\n\tfont-size:18.0pt;\n\tfont-weight:400;\n\tfont-style:normal;\n\ttext-decoration:none;\n\tfont-family:Arial;\n\tmso-generic-font-family:auto;\n\tmso-font-charset:0;\n\ttext-align:general;\n\tvertical-align:bottom;\n\tborder:none;\n\tmso-background-source:auto;\n\tmso-pattern:auto;}\n.oa1\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa2\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa3\n\t{border-top:2.25pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa4\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa5\n\t{border:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa6\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa7\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa8\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa9\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n-->\n</style>\n\n\n\n\n\n</p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"862\" style=\"width: 646pt;\">\n <colgroup><col width=\"257\">\n <col width=\"260\">\n <col width=\"345\">\n </colgroup><tbody><tr height=\"29\">\n  <td height=\"29\" class=\"oa1\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">协议</span></p>\n  </td>\n  <td class=\"oa2\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TOS</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">位</span></p>\n  </td>\n  <td class=\"oa3\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">说明</span></p>\n  </td>\n </tr>\n <tr height=\"28\">\n  <td height=\"28\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">ICMP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">正常</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">BOOTP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">正常</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">NNTP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0001</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小代价</span></p>\n  </td>\n </tr>\n <tr height=\"28\">\n  <td height=\"28\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">IGP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0010</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最高可靠性</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">SNMP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0010</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最高可靠性</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TELNET</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"28\">\n  <td height=\"28\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">FTP(</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">数据</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0100</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最大吞吐量</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">FTP(</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">控制</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TFTP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"28\">\n  <td height=\"28\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">SMTP(</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">命令</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">SMTP(</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">数据</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0100</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最大吞吐量</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">DNS(UDP</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">查询</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最小延时</span></p>\n  </td>\n </tr>\n <tr height=\"28\">\n  <td height=\"28\" class=\"oa4\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">DNS(TCP</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">查询</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa5\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0000</span></p>\n  </td>\n  <td class=\"oa6\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">正常</span></p>\n  </td>\n </tr>\n <tr height=\"29\">\n  <td height=\"29\" class=\"oa7\" width=\"257\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">DNS(</span><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">区域</span><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">)</span></p>\n  </td>\n  <td class=\"oa8\" width=\"260\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">0100</span></p>\n  </td>\n  <td class=\"oa9\" width=\"345\">\n  <p style=\"line-height: normal; margin: 4.8pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 20pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">最大吞吐量</span></p>\n  </td>\n </tr>\n</tbody></table><p><br></p><h3>数据报是可变长度分组，由两部分组成：首部和数据。首部可以从20~60字节，包括有关路由选择和交付的重要信息。</h3><p><br></p><h3>总长度：这个16位字段定义的以字节计的数据报总长度（首部加上数据），因此IP数据报的长度限制是65535字节，其中首部占20~60字节，剩下的是从上层传送来的数据。</h3><p><br></p><p>生存时间：数据报通过互联网时必须具有受限的寿命。现在这个字段基本上是用来控制数据报所通过路由器的最大跳数。当源主机发送数据报时，它在这个字段存入一个数，这个数值约为任何两个主机之间的路由器数的两倍。</p><p><br></p><h2><blockquote>协议</blockquote></h2><p>协议：这个8位字段定义使用IP层服务的高层协议。这个字段指明IP数据报必须交付到的最终目的协议。</p><p><br></p><p><style>\n<!--tr\n\t{mso-height-source:auto;}\ncol\n\t{mso-width-source:auto;}\ntd\n\t{padding-top:1.0px;\n\tpadding-right:1.0px;\n\tpadding-left:1.0px;\n\tmso-ignore:padding;\n\tcolor:windowtext;\n\tfont-size:18.0pt;\n\tfont-weight:400;\n\tfont-style:normal;\n\ttext-decoration:none;\n\tfont-family:Arial;\n\tmso-generic-font-family:auto;\n\tmso-font-charset:0;\n\ttext-align:general;\n\tvertical-align:bottom;\n\tborder:none;\n\tmso-background-source:auto;\n\tmso-pattern:auto;}\n.oa1\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa2\n\t{border-top:2.25pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa3\n\t{border-top:2.25pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa4\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa5\n\t{border:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa6\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:1.0pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa7\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:2.25pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa8\n\t{border-top:1.0pt solid black;\n\tborder-right:1.0pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n.oa9\n\t{border-top:1.0pt solid black;\n\tborder-right:2.25pt solid black;\n\tborder-bottom:2.25pt solid black;\n\tborder-left:1.0pt solid black;\n\ttext-align:center;\n\tvertical-align:middle;\n\tpadding-bottom:3.6pt;\n\tpadding-left:7.2pt;\n\tpadding-top:3.6pt;\n\tpadding-right:7.2pt;}\n-->\n</style>\n\n\n\n\n\n</p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"918\" style=\"width: 689pt;\">\n <colgroup><col width=\"230\" span=\"2\">\n <col width=\"229\">\n <col width=\"230\">\n </colgroup><tbody><tr height=\"91\">\n  <td height=\"91\" class=\"oa1\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">值</span></p>\n  </td>\n  <td class=\"oa2\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">协议</span></p>\n  </td>\n  <td class=\"oa2\" width=\"229\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">值</span></p>\n  </td>\n  <td class=\"oa3\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-family: 宋体; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">协议</span></p>\n  </td>\n </tr>\n <tr height=\"91\">\n  <td height=\"91\" class=\"oa4\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">1</span></p>\n  </td>\n  <td class=\"oa5\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">ICMP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"229\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">17</span></p>\n  </td>\n  <td class=\"oa6\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">UDP</span></p>\n  </td>\n </tr>\n <tr height=\"91\">\n  <td height=\"91\" class=\"oa4\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">2</span></p>\n  </td>\n  <td class=\"oa5\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">IGMP</span></p>\n  </td>\n  <td class=\"oa5\" width=\"229\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">89</span></p>\n  </td>\n  <td class=\"oa6\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">OSPF</span></p>\n  </td>\n </tr>\n <tr height=\"91\">\n  <td height=\"91\" class=\"oa7\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">6</span></p>\n  </td>\n  <td class=\"oa8\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"><span style=\"font-size: 28pt; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: bold; vertical-align: baseline;\">TCP</span></p>\n  </td>\n  <td class=\"oa8\" width=\"229\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"></p>\n  </td>\n  <td class=\"oa9\" width=\"230\">\n  <p style=\"line-height: normal; margin: 6.72pt 0in 0pt; text-indent: 0in; direction: ltr; unicode-bidi: embed; vertical-align: baseline; word-break: normal;\"></p>\n  </td>\n </tr>\n</tbody></table><br><p><br></p>',0,0,'2019-06-17 11:43:45',NULL,'','计算机网络',1);

#
# Structure for table "article_category_ref"
#

CREATE TABLE `article_category_ref` (
  `article_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

#
# Data for table "article_category_ref"
#


#
# Structure for table "category"
#

CREATE TABLE `category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(255) DEFAULT NULL,
  `category_create_time` datetime DEFAULT NULL,
  `category_update_time` datetime DEFAULT NULL,
  `category_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

#
# Data for table "category"
#

INSERT INTO `category` VALUES (1,'JAVA基础','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(2,'WEB前端','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(3,'JAVA后端','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(4,'算法','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(5,'数据库','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(6,'杂文随笔','2019-05-31 22:30:05','2019-05-31 22:30:05',1),(7,'计算机网络','2019-05-31 22:30:05','2019-05-31 22:30:05',1);

#
# Structure for table "comment"
#

CREATE TABLE `comment` (
  `comment_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `comment_article_id` int(11) unsigned DEFAULT NULL,
  `comment_author_name` int(11) DEFAULT '0',
  `comment_content` varchar(1000) DEFAULT NULL,
  `comment_create_time` datetime DEFAULT NULL,
  `comment_author_img` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

#
# Data for table "comment"
#

INSERT INTO `comment` VALUES (1,1,1,'写得真好啊<img src=\"http://localhost:8080/Blog/plug/layui/images/face/39.gif\" alt=\"[鼓掌]\">','2019-06-02 14:25:54','1'),(2,1,3,'123<img alt=\"[嘻嘻]\" src=\"http://localhost:8080/Blog/plug/layui/images/face/1.gif\">','2019-06-02 15:38:42','1'),(3,1,1,'123','2019-06-13 18:52:28',NULL),(4,1,1,'a','2019-06-14 23:07:07',NULL);

#
# Structure for table "link"
#

CREATE TABLE `link` (
  `link_id` int(11) NOT NULL AUTO_INCREMENT,
  `linl_name` varchar(255) DEFAULT NULL,
  `link_url` varchar(255) DEFAULT NULL,
  `link_update_time` datetime DEFAULT NULL,
  `link_create_time` datetime DEFAULT NULL,
  `link_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`link_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

#
# Data for table "link"
#

INSERT INTO `link` VALUES (1,'CSDN','www.csdn.net','2019-06-02 10:51:13','2019-05-31 22:30:05',1),(2,'Layui','www.layui.com','2019-06-02 12:01:47','2019-06-02 12:01:47',1),(3,'GitHub','github.com','2019-06-02 12:01:47','2019-06-02 12:01:47',1),(4,'LeetCode','leetcode-cn.com3','2019-06-02 16:03:56','2019-06-02 12:01:47',1);

#
# Structure for table "notice"
#

CREATE TABLE `notice` (
  `notice_id` int(11) NOT NULL AUTO_INCREMENT,
  `notice_title` varchar(255) DEFAULT NULL,
  `notice_content` varchar(10000) DEFAULT NULL,
  `notice_create_time` datetime DEFAULT NULL,
  `notice_update_time` datetime DEFAULT NULL,
  `notice_status` int(1) unsigned DEFAULT '1',
  PRIMARY KEY (`notice_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

#
# Data for table "notice"
#

INSERT INTO `notice` VALUES (1,'博客系统1.0上线啦','博客目前还处于建设阶段，正在不断完善中','2019-06-02 12:01:47','2019-06-02 16:03:56',1),(2,'有问题可以留言噢','','2019-06-02 12:01:47','2019-06-02 16:03:56',1);

#
# Structure for table "user"
#

CREATE TABLE `user` (
  `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL DEFAULT '',
  `user_pass` varchar(255) NOT NULL DEFAULT '',
  `user_nickname` varchar(255) NOT NULL DEFAULT '',
  `user_email` varchar(100) DEFAULT '',
  `user_img` varchar(255) DEFAULT NULL,
  `user_register_time` datetime DEFAULT NULL,
  `user_last_login_time` datetime DEFAULT NULL,
  `user_status` int(1) unsigned DEFAULT '0',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_name` (`user_name`),
  UNIQUE KEY `user_email` (`user_email`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

#
# Data for table "user"
#

INSERT INTO `user` VALUES (1,'admin','123456','Ajar','JAVA@stu.jluzh.edu.cn','/uploads/2017/10/20171006225356181.jpg','2019-05-09 19:12:26','2019-06-16 11:04:12',1),(2,'zhangsan','123456','张三','zhangsan@china.com','/uploads/2018/11/avatar(1).jpg','2019-05-09 19:12:26','2019-05-09 19:12:26',1),(3,'1','1','普通用户','1@china.com',NULL,'2019-05-09 19:12:26','2019-06-04 19:10:22',0);
